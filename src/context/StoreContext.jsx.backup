import React, { createContext, useContext, useState, useEffect } from 'react';

    ]);
const [supplierProducts, setSupplierProducts] = useState([]);
const [purchases, setPurchases] = useState([]);

// Claims & Surveys State (Mock for now)
const [claims, setClaims] = useState([
    { id: 1, customerId: 1, type: 'Devolución', product: 'Carpa 4 Personas', reason: 'Defecto de fábrica', status: 'Abierto', date: '2023-11-24' },
]);
const [surveys, setSurveys] = useState([
    { id: 1, customerId: 1, rating: 5, comment: 'Excelente servicio', date: '2023-11-21' },
]);

// Load Data from API
useEffect(() => {
    const loadData = async () => {
        setLoading(true);
        await Promise.all([
            fetchProducts(),
            fetchSales(),
            fetchCustomers(),
            fetchSuppliers(),
            fetchPurchases(),
            fetchClaims(),
            fetchSurveys()
        ]);
        setLoading(false);
    };
    loadData();
}, []);

const fetchProducts = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/products');
        const data = await res.json();
        if (Array.isArray(data)) {
            setProducts(data);
        } else {
            console.error("Expected array for products, got:", data);
            setProducts([]);
        }
    } catch (error) {
        console.error("Error fetching products:", error);
        setProducts([]);
    }
};

const fetchSales = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/sales');
        const data = await res.json();

        if (Array.isArray(data)) {
            setSales(data);

            // Calculate counters based on history
            let b = 0, f = 0, t = 0;
            data.forEach(s => {
                if (s.receiptNumber && s.receiptNumber.startsWith('B')) b = Math.max(b, parseInt(s.receiptNumber.substring(1)) || 0);
                if (s.receiptNumber && s.receiptNumber.startsWith('F')) f = Math.max(f, parseInt(s.receiptNumber.substring(1)) || 0);
                if (s.receiptNumber && s.receiptNumber.startsWith('T')) t = Math.max(t, parseInt(s.receiptNumber.substring(1)) || 0);
            });
            setReceiptCounters({ boleta: b, factura: f, ticket: t });
        } else {
            console.error("Expected array for sales, got:", data);
            setSales([]);
        }

    } catch (error) {
        console.error("Error fetching sales:", error);
        setSales([]);
    }
};

const fetchCustomers = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/customers');
        const data = await res.json();
        if (Array.isArray(data)) {
            setCustomers(data);
        } else {
            console.error("Expected array for customers, got:", data);
            setCustomers([]);
        }
    } catch (error) {
        console.error("Error fetching customers:", error);
        setCustomers([]);
    }
};

const fetchSuppliers = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/suppliers');
        const data = await res.json();
        if (Array.isArray(data)) {
            setSuppliers(data);
        } else {
            console.error("Expected array for suppliers, got:", data);
            setSuppliers([]);
        }
    } catch (error) {
        console.error("Error fetching suppliers:", error);
        setSuppliers([]);
    }
};

const fetchPurchases = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/purchases');
        const data = await res.json();

        if (Array.isArray(data)) {
            // Parse items if they come as string or ensure structure
            const parsedData = data.map(p => ({
                ...p,
                items: p.items || [] // items are aggregated as json in query
            }));
            setPurchases(parsedData);
        } else {
            console.error("Expected array for purchases, got:", data);
            setPurchases([]);
        }
    } catch (error) {
        console.error("Error fetching purchases:", error);
        setPurchases([]);
    }
};

const fetchClaims = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/claims');
        const data = await res.json();
        if (Array.isArray(data)) {
            setClaims(data);
        } else {
            console.error("Expected array for claims, got:", data);
            setClaims([]);
        }
    } catch (error) {
        console.error("Error fetching claims:", error);
        setClaims([]);
    }
};

const fetchSurveys = async () => {
    try {
        const res = await fetch('http://localhost:3001/api/surveys');
        const data = await res.json();
        if (Array.isArray(data)) {
            setSurveys(data);
        } else {
            console.error("Expected array for surveys, got:", data);
            setSurveys([]);
        }
    } catch (error) {
        console.error("Error fetching surveys:", error);
        setSurveys([]);
    }
};

// --- CART ACTIONS ---
const addToCart = (product) => {
    setCart(prev => {
        const existing = prev.find(item => item.id === product.id);
        const currentQty = existing ? existing.quantity : 0;

        if (currentQty + 1 > product.stock) {
            alert(`Stock insuficiente. Solo quedan ${product.stock} unidades.`);
            return prev;
        }

        if (existing) {
            return prev.map(item => item.id === product.id ? { ...item, quantity: item.quantity + 1 } : item);
        }
        return [...prev, { ...product, quantity: 1 }];
    });
};

const removeFromCart = (productId) => {
    setCart(prev => prev.filter(item => item.id !== productId));
};

const updateQuantity = (productId, quantity) => {
    if (quantity < 1) return;
    setCart(prev => prev.map(item => item.id === productId ? { ...item, quantity } : item));
};

const clearCart = () => setCart([]);

// --- SALES ACTIONS ---
const addSale = (saleData) => {
    let prefix = 'T';
    let counterKey = 'ticket';

    if (saleData.receiptType === 'boleta') {
        prefix = 'B';
        counterKey = 'boleta';
    } else if (saleData.receiptType === 'factura') {
        prefix = 'F';
        counterKey = 'factura';
    }

    const newCount = receiptCounters[counterKey] + 1;
    const receiptNumber = `${prefix}${String(newCount).padStart(3, '0')}`;

    setReceiptCounters(prev => ({ ...prev, [counterKey]: newCount }));

    const newSale = {
        ...saleData,
        receiptNumber,
        cartItems: cart // Pass cart items to backend
    };

    // Optimistic Update
    setSales(prev => [newSale, ...prev]);

    // Send to API
    fetch('http://localhost:3001/api/sales', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newSale)
    })
        .then(res => res.json())
        .then(() => {
            fetchProducts(); // Refresh stock
        })
        .catch(err => console.error("Error saving sale:", err));

    return newSale;
};

// --- PRODUCT ACTIONS ---
const addProduct = async (product) => {
    try {
        const res = await fetch('http://localhost:3001/api/products', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(product)
        });
        const newProduct = await res.json();
        setProducts(prev => [...prev, newProduct]);
    } catch (err) {
        console.error("Error adding product:", err);
    }
};

const updateProduct = async (id, updatedData) => {
    try {
        await fetch(`http://localhost:3001/api/products/${id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updatedData)
        });
        setProducts(prev => prev.map(p => p.id === id ? { ...p, ...updatedData } : p));
    } catch (err) {
        console.error("Error updating product:", err);
    }
};

const deleteProduct = async (id) => {
    try {
        await fetch(`http://localhost:3001/api/products/${id}`, { method: 'DELETE' });
        setProducts(prev => prev.filter(p => p.id !== id));
    } catch (err) {
        console.error("Error deleting product:", err);
    }
};

// --- SUPPLIER & PURCHASE ACTIONS ---
const addSupplier = async (supplier) => {
    try {
        const res = await fetch('http://localhost:3001/api/suppliers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(supplier)
        });
        const newSupplier = await res.json();
        setSuppliers(prev => [...prev, newSupplier]);
    } catch (err) {
        console.error("Error adding supplier:", err);
    }
};

const addSupplierProduct = (entry) => {
    setSupplierProducts(prev => {
        const existing = prev.find(sp => sp.supplierId === entry.supplierId && sp.productId === entry.productId);
        if (existing) {
            return prev.map(sp => (sp.supplierId === entry.supplierId && sp.productId === entry.productId) ? entry : sp);
        }
        return [...prev, entry];
    });
};

const syncSupplierPrices = async (supplierId) => {
    try {
        const res = await fetch(`http://localhost:3001/api/supplier-products/${supplierId}`);
        const data = await res.json();

        // Update supplier products with the fetched data
        const formattedProducts = data.map(item => ({
            id: item.id,
            supplierId: item.supplierid,
            productId: item.productid,
            name: item.productname,
            price: item.price,
            stock: item.stock,
            category: item.category
        }));

        // Replace existing products for this supplier
        setSupplierProducts(prev => [
            ...prev.filter(sp => sp.supplierId !== parseInt(supplierId)),
            ...formattedProducts
        ]);

        console.log(`Loaded ${formattedProducts.length} products for supplier ${supplierId}`);
        return true;
    } catch (error) {
        console.error('Error syncing supplier prices:', error);
        return false;
    }
};

const placeSupplierOrder = async (orderData) => {
    console.log("Placing order:", orderData);
    // Simulate success
    const newPurchase = {
        ...orderData,
        id: Date.now(),
        date: new Date().toISOString(),
        status: 'Pending',
        invoiceNumber: `ORD-${Date.now()}`
    };
    setPurchases(prev => [newPurchase, ...prev]);
    return { success: true, message: "Orden simulada enviada correctamente" };
};

const addPurchase = (purchase) => {
    // This seems redundant with placeSupplierOrder but kept for compatibility if used elsewhere
    // Ideally should also call API
    console.warn("addPurchase called directly, consider using placeSupplierOrder for full integration");
    const newPurchase = { ...purchase, id: Date.now(), date: new Date().toISOString(), status: 'Pending' };
    setPurchases(prev => [newPurchase, ...prev]);
};

const updatePurchaseStatus = async (purchaseId, newStatus) => {
    try {
        await fetch(`http://localhost:3001/api/purchases/${purchaseId}/status`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: newStatus })
        });

        setPurchases(prev => prev.map(p => {
            if (p.id === purchaseId) {
                if (newStatus === 'Confirmed' && p.status !== 'Confirmed') {
                    // Increase Stock (Optimistic - ideally backend handles this transactionally)
                    // For now we just update frontend state, assuming backend logic could be added later or separate stock adjustment
                    setProducts(currentProducts => currentProducts.map(prod => {
                        const item = p.items.find(i => i.productId === prod.id);
                        return item ? { ...prod, stock: prod.stock + item.quantity, cost: item.cost || prod.cost } : prod;
                    }));
                } else if (newStatus === 'Cancelled' && p.status === 'Confirmed') {
                    // Decrease Stock
                    setProducts(currentProducts => currentProducts.map(prod => {
                        const item = p.items.find(i => i.productId === prod.id);
                        return item ? { ...prod, stock: prod.stock - item.quantity } : prod;
                    }));
                }
                return { ...p, status: newStatus };
            }
            return p;
        }));
    } catch (err) {
        console.error("Error updating purchase status:", err);
    }
};

// --- CRM ACTIONS ---
const addCustomer = (customer) => {
    // TODO: Implement API for customers
    setCustomers(prev => [...prev, { ...customer, id: Date.now(), points: 0, totalPurchases: 0, type: 'Nuevo' }]);
};

const updateCustomerPoints = (customerId, points) => {
    // TODO: Implement API
    setCustomers(prev => prev.map(c => c.id === customerId ? { ...c, points: c.points + points } : c));
};

const addClaim = async (claim) => {
    try {
        const res = await fetch('http://localhost:3001/api/claims', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(claim)
        });
        const newClaim = await res.json();
        setClaims(prev => [newClaim, ...prev]);
    } catch (err) {
        console.error("Error adding claim:", err);
    }
};

const updateClaimStatus = (claimId, status, resolution = '') => {
    // TODO: Implement API
    setClaims(prev => prev.map(c => c.id === claimId ? { ...c, status, resolution } : c));
};

const value = {
    products, setProducts, addProduct, updateProduct, deleteProduct,
    cart, addToCart, removeFromCart, clearCart, updateQuantity,
    suppliers, setSuppliers, addSupplier,
    supplierProducts, addSupplierProduct, syncSupplierPrices,
    purchases, addPurchase, placeSupplierOrder, updatePurchaseStatus,
    customers, addCustomer, updateCustomerPoints,
    claims, addClaim, updateClaimStatus,
    surveys,
    sales, addSale,
    loading
};

return (
    <StoreContext.Provider value={value}>
        {children}
    </StoreContext.Provider>
);
};
